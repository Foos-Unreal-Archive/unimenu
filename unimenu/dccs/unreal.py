import unreal
import warnings
# from unimenu.dccs.qt import QtMenuMaker
from unimenu.dccs._abstract import MenuNodeAbstract, AbstractMenuMaker


class MenuMaker(AbstractMenuMaker):  # todo believe this doesnt need qt, but can use normal menumaker
    @classmethod
    def setup_menu(cls, data):
        parent_menu_name = data.get("parent", "LevelEditor.MainMenu")
        unreal_menus = unreal.ToolMenus.get()
        parent_menu = unreal_menus.find_menu(parent_menu_name)
        if not parent_menu:
            warnings.warn(f"Parent menu '{parent_menu_name}' not found, couldn't setup menu")

        menu_items = cls._setup_menu_items(parent_menu, data.get("items"))
        unreal_menus.refresh_all_widgets()
        return menu_items
        # TODO decide to return success/failure, or the menu object

    @classmethod
    def add_to_menu(cls, parent, label: str, command: str, icon=None, tooltip=None) -> unreal.ToolMenuEntry:
        """add a menu item to the script menu"""

        icon = icon or ""
        tooltip = tooltip or ""

        entry = unreal.ToolMenuEntry(
            # name="Python.MyCoolTool",  # this needs to be unique! if not set, it's autogenerated
            type=unreal.MultiBlockType.MENU_ENTRY,
            insert_position=unreal.ToolMenuInsert("", unreal.ToolMenuInsertType.FIRST),
        )
        if label:
            entry.set_label(label)
        if command:
            entry.set_string_command(
                type=unreal.ToolMenuStringCommandType.PYTHON,
                string=command,
                custom_type=unreal.Name("_placeholder_"),
            )  # hack: unsure what custom_type does, but it's needed
        if tooltip:
            entry.set_tool_tip(tooltip)
        if icon:
            entry.set_icon(icon)  # naive implementation todo improve

        parent.add_menu_entry("Scripts", entry)  # always returns None
        return entry

    @classmethod
    def add_sub_menu(cls, parent, label: str, tool_tip=None) -> unreal.ToolMenu:
        """add a submenu to the script menu"""

        tool_tip = tool_tip or ""

        return parent.add_sub_menu(
            owner=parent.menu_name,
            section_name="PythonTools",
            name=label,  # todo check if needs to be uniqye like in add_to_menu
            label=label,  # todo add label support
            tool_tip=tool_tip,
        )

    @classmethod
    def add_separator(cls, parent, label: str = None) -> None:  # todo not working yet
        """add a separator to the script menu"""
        # see https://docs.unrealengine.com/4.27/en-US/PythonAPI/class/ToolMenu.html
        # todo what is diff with dynamic section?
        return parent.add_section(section_name="Test", label="World")

    @classmethod
    def teardown(cls):
        """remove from menu"""
        raise NotImplementedError("not yet implemented")


class MenuNodeUnreal(MenuNodeAbstract):

    @property
    def _default_root_parent(self):
        parent_menu_name = "LevelEditor.MainMenu"
        unreal_menus = unreal.ToolMenus.get()
        parent_menu = unreal_menus.find_menu(parent_menu_name)
        return parent_menu

    def setup(self, parent_app_node=None):
        super().setup(parent_app_node=parent_app_node)

        # post setup
        unreal_menus = unreal.ToolMenus.get()
        unreal_menus.refresh_all_widgets()


    def _setup_sub_menu(self, parent_app_node=None):
        return MenuMaker.add_sub_menu(parent=parent_app_node, label=self.label, tool_tip=self.tooltip)

    def _setup_menu_item(self, parent_app_node=None):
        return MenuMaker.add_to_menu(parent=parent_app_node, label=self.label, command=self.command, icon=self.icon, tooltip=self.tooltip)

    def _setup_separator(self, parent_app_node=None):
        return MenuMaker.add_separator(parent=parent_app_node, label=self.label)

    def _teardown(self):
        return MenuMaker.teardown()